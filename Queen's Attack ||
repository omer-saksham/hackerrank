#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Helper function to find the minimum of two integers
int min(int a, int b) {
    return (a < b) ? a : b;
}

// The core logic function
long queensAttack(int n, int k, int r_q, int c_q, int **obstacles) {
    
    // Initialize the maximum reach for the 8 directions (distance to edge)
    long up = n - r_q;
    long down = r_q - 1;
    long right = n - c_q;
    long left = c_q - 1;
    
    long up_right = min(up, right);
    long up_left = min(up, left);
    long down_right = min(down, right);
    long down_left = min(down, left);
    
    for (int i = 0; i < k; i++) {
        int r_o = obstacles[i][0];
        int c_o = obstacles[i][1];
        
        // 1. Vertical and Horizontal Checks
        if (c_o == c_q) { // Same column
            if (r_o > r_q) up = min(up, r_o - r_q - 1);
            else if (r_o < r_q) down = min(down, r_q - r_o - 1);
        }
        else if (r_o == r_q) { // Same row
            if (c_o > c_q) right = min(right, c_o - c_q - 1);
            else if (c_o < c_q) left = min(left, c_q - c_o - 1);
        }
        
        // 2. Diagonal Checks
        else if (abs(r_o - r_q) == abs(c_o - c_q)) {
            long dist = abs(r_o - r_q) - 1;
            
            if (r_o > r_q && c_o > c_q) up_right = min(up_right, dist);
            else if (r_o > r_q && c_o < c_q) up_left = min(up_left, dist);
            else if (r_o < r_q && c_o > c_q) down_right = min(down_right, dist);
            else if (r_o < r_q && c_o < c_q) down_left = min(down_left, dist);
        }
    }
    
    long total_attacks = up + down + left + right + up_right + up_left + down_right + down_left;
    
    return total_attacks;
}

// ----------------------------------------------------------------------
// *** This is the missing 'main' function to fix your linker error ***
// ----------------------------------------------------------------------
int main() {
    int n, k;
    if (scanf("%d %d", &n, &k) != 2) return 1;

    int r_q, c_q;
    if (scanf("%d %d", &r_q, &c_q) != 2) return 1;

    // Dynamically allocate memory for obstacles
    int **obstacles = NULL;
    if (k > 0) {
        obstacles = (int **)malloc(k * sizeof(int *));
        if (obstacles == NULL) return 1; // Check allocation
        
        for (int i = 0; i < k; i++) {
            obstacles[i] = (int *)malloc(2 * sizeof(int));
            if (obstacles[i] == NULL) return 1; // Check allocation
            if (scanf("%d %d", &obstacles[i][0], &obstacles[i][1]) != 2) return 1;
        }
    }

    // Call the function and print the result
    long result = queensAttack(n, k, r_q, c_q, obstacles);
    printf("%ld\n", result);

    // Free allocated memory
    for (int i = 0; i < k; i++) {
        free(obstacles[i]);
    }
    free(obstacles);

    return 0;
}
